import{_ as e,c as n,o as a,a3 as s}from"./chunks/framework.C5U8cnJv.js";const p="/xhh-blog/assets/image-8.n1BIbWBI.png",b=JSON.parse('{"title":"npm 模块安装机制","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs/npm模块安装机制.md","filePath":"nodejs/npm模块安装机制.md"}'),l={name:"nodejs/npm模块安装机制.md"},i=s(`<h1 id="npm-模块安装机制" tabindex="-1">npm 模块安装机制 <a class="header-anchor" href="#npm-模块安装机制" aria-label="Permalink to &quot;npm 模块安装机制&quot;">​</a></h1><h2 id="npm-不同版本之间的差异" tabindex="-1">npm 不同版本之间的差异 <a class="header-anchor" href="#npm-不同版本之间的差异" aria-label="Permalink to &quot;npm 不同版本之间的差异&quot;">​</a></h2><h3 id="npm2" tabindex="-1">npm2 <a class="header-anchor" href="#npm2" aria-label="Permalink to &quot;npm2&quot;">​</a></h3><p>层层嵌套的方式递归遍历安装，会形成嵌套地狱</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├── A@1.0.0</span></span>
<span class="line"><span>│   └── node_modules</span></span>
<span class="line"><span>│       └── B@1.0.0</span></span>
<span class="line"><span>└── C@1.0.0</span></span>
<span class="line"><span>    └── node_modules</span></span>
<span class="line"><span>        └── B@1.0.0</span></span>
<span class="line"><span>        └── D@1.0.0</span></span></code></pre></div><h3 id="npm3" tabindex="-1">npm3 <a class="header-anchor" href="#npm3" aria-label="Permalink to &quot;npm3&quot;">​</a></h3><p>扁平化安装，子依赖会尽可能平铺在主依赖所在的目录中。</p><p>那如果遇到相同包依赖不同的子模块又会怎样呢？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├── A@1.0.0</span></span>
<span class="line"><span>├── B@1.0.0</span></span>
<span class="line"><span>└── C@1.0.0</span></span>
<span class="line"><span>     └── node_modules</span></span>
<span class="line"><span>         └── B@2.0.0</span></span></code></pre></div><p>可以看到 A 的子依赖的 B@1.0 不会放在 A 的 node_modules 下了，而是与 A 同层级。</p><p>而 C 依赖的 B@2.0 因为版本号原因还是放到了 C 的 node_modules 下。</p><p>虽然扁平化一定程度上解决了依赖过深的问题，但也引发了新的问题：</p><ul><li>隐式依赖风险</li></ul><p>扁平化依赖会导致node_modules下多出来并未在package.json声明的包，这些多出来的包也可以在项目中导入使用，这就存在隐式依赖风险。</p><p>如果项目里引入这些多出来的包，宿主包被删除，对应的依赖也不会安装，就会出现报错。</p><ul><li>依赖结构变化</li></ul><p>相同包依赖不同的子模块也有可能这样安装</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├── A@1.0.0</span></span>
<span class="line"><span>│   └── node_modules</span></span>
<span class="line"><span>│       └── B@1.0.0</span></span>
<span class="line"><span>├── B@2.0.0</span></span>
<span class="line"><span>└── C@1.0.0</span></span></code></pre></div><h3 id="npm5" tabindex="-1">npm5 <a class="header-anchor" href="#npm5" aria-label="Permalink to &quot;npm5&quot;">​</a></h3><p>npm5 新增了锁定依赖功能的package-lock.json文件，记录包版本信息及安装顺序，用来保证项目下次安装时依赖结构的一致性。</p><h3 id="npm7" tabindex="-1">npm7 <a class="header-anchor" href="#npm7" aria-label="Permalink to &quot;npm7&quot;">​</a></h3><p>npm v7 会自动安装 peerDependencies 里面的模块。</p><p>如果在 npm install 的时候加上 --legacy-peer-deps 参数，npm 就不会自动安装 peerDependencies 依赖，也就是让 npm v7 用旧的（v3~v6）的处理方式来。</p><h2 id="dependencies" tabindex="-1">dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;dependencies&quot;">​</a></h2><p>运行时的依赖。发布后，即生产环境下需要用的模块（生产依赖）</p><p>npm install --production 指令，只会安装 dependencies 目录下的依赖；</p><p>引入npm发布的包时，包中有生产依赖dependencies和开发依赖devDependencies时只会下载dependencies中的依赖。</p><h2 id="devdependencies" tabindex="-1">devDependencies <a class="header-anchor" href="#devdependencies" aria-label="Permalink to &quot;devDependencies&quot;">​</a></h2><p>开发时的依赖。</p><h2 id="peerdependencies" tabindex="-1">peerDependencies <a class="header-anchor" href="#peerdependencies" aria-label="Permalink to &quot;peerDependencies&quot;">​</a></h2><p>对等依赖，目的是提示宿主环境去安装满足插件peerDependencies所指定依赖的包。</p><p>举例（npm v3-v6）：</p><p>antd 是基于 react 构建的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>&quot;peerDependencies&quot;: {</span></span>
<span class="line"><span>	&quot;react&quot;: &quot;&gt;=16.9.0&quot;,</span></span>
<span class="line"><span>	&quot;react-dom&quot;: &quot;&gt;=16.9.0&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>如果环境中已经有 react (版本号&gt;=16.9.0)的，那么就可以正常使用。</p><p>如果环境没 react，安装 antd 时，就会报类似下面的错： <img src="`+p+`" alt="alt text"></p><p>这种情况要在项目的package.json文件指定安装react, react-dom依赖；如果是npm7，会自动安装peerDependencies里面的模块。</p><h2 id="optionaldependencies" tabindex="-1">optionalDependencies <a class="header-anchor" href="#optionaldependencies" aria-label="Permalink to &quot;optionalDependencies&quot;">​</a></h2><p>某些场景下，依赖包可能不是强依赖的，这个依赖包的功能可有可无，一定要做好异常处理。</p><p>optionalDependencies 中的配置将会覆盖掉 dependencies，所以只需在一个地方进行配置。</p><h2 id="bundleddependencies" tabindex="-1">bundledDependencies <a class="header-anchor" href="#bundleddependencies" aria-label="Permalink to &quot;bundledDependencies&quot;">​</a></h2><p>bundledDependencies 的值是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。 &quot;bundledDependencies&quot;: [&quot;package1&quot; , &quot;package2&quot;]</p><h2 id="模块版本号" tabindex="-1">模块版本号 <a class="header-anchor" href="#模块版本号" aria-label="Permalink to &quot;模块版本号&quot;">​</a></h2><p>版本号格式：主版本号.次版本号.补丁版本号</p><p>版本号递增规则如下：</p><p>1.主版本号：不兼容的 API 修改</p><p>2.次版本号：向下兼容的功能性新增</p><p>3.补丁版本号：向下兼容的问题修复</p><ul><li><strong>^(插入符)</strong></li></ul><p>比如：^10.11.2</p><p>版本范围：10.11.2 &lt;= version &lt; 11.0.0</p><p>主版本号不变</p><ul><li><strong>~(波浪符)</strong></li></ul><p>比如：~10.11.2</p><p>版本范围：10.11.2 &lt;= version &lt; 10.12.0</p><p>主版本号和次版本号都不变</p><ul><li><strong>@</strong></li></ul><p>安装特定版本，比如：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>npm install express@4.17.1</span></span>
<span class="line"><span>或</span></span>
<span class="line"><span>&quot;dependencies&quot;: {</span></span>
<span class="line"><span>  &quot;express&quot;: &quot;4.17.1&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong>&gt; 或 &gt;=</strong></li></ul><p>安装大于（等于） 指定版本 的最新版本</p><ul><li><strong>&lt; 或 &lt;=</strong></li></ul><p>安装小于（等于） 指定版本 的最新版本</p><ul><li><strong>星*符号</strong></li></ul><p>任意版本</p><h2 id="模块安装位置" tabindex="-1">模块安装位置 <a class="header-anchor" href="#模块安装位置" aria-label="Permalink to &quot;模块安装位置&quot;">​</a></h2><ul><li>--save:（-S）package.json的dependencies节点。</li><li>--save-dev:（-D）package.json的devDependencies节点。</li><li>--save-optional：(-O) package.json的optionalDependencies节点。</li><li>--global: (-g) 全局安装，不会将模块依赖记录在 dependencies或devDependencies中。</li></ul><p>参考文档： <a href="https://docs.npmjs.com/cli/v10/commands/npm-install/" target="_blank" rel="noreferrer">https://docs.npmjs.com/cli/v10/commands/npm-install/</a></p><h2 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h2><ul><li><p>建议把项目package-lock.json文件提交到git仓库中，从而保证团队成员安装依赖包的一致性。</p></li><li><p>开发npm包时，不建议将package-lock.json文件上传（npm发布时默认是不上传package-lock.json文件的）。</p></li></ul>`,70),t=[i];function o(d,c,r,u,h,m){return a(),n("div",null,t)}const q=e(l,[["render",o]]);export{b as __pageData,q as default};
